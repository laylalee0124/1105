[ Constructor ]
	- ☆☆☆☆메소드명이 클래스명과 동일하고 리턴 자료형이 없는 메소드를 생성자(Constructor)라고 말한다.
	- 일반적으로 멤버변수의 초기화를 담당한다. 
	- 클래스를 만들면 default 초기화를 해주는 기본 생성자가 존재한다.
	- 모든 클래스는 생성자가 존재.
	- construntor는 overloading를 허용하고. No argument constructor(parameter x) / parameterized constructor(parameter x)로 나눈다.
	**생성자는 클래스가 new 표현식에 의해 인스턴스화되어 객체를 생성할 때 객체의 레퍼런스를 생성하기 전에 객체의 초기화를 위해 사용되는 코드의 블록이다.
	**따라서, 생성자는 자바 클래스의 멤버가 아니며, 멤버가 아니므로 상속되지 않는다. 따라서, 오버라이딩의 대상이 될 수도 없다. 또한, 일반적인 메소드 호출방법으로 호출할 수 없다.
	생성자는 접근 제한 수식어인 public, protected, private 만을 쓸 수 있으며, abstract, final, native, static, strictfp, synchronized 등의 수식어를 사용할 수 없다. 접근 제한이 생략된 경우 클래스와 마찬가지로 package 접근 제한이 설정된다. 생성자는 접근제어를 통해 클래스의 인스턴스화를 통한 객체 생성을 조절할 수 있지만, 이러한 접근 제어는 생성자가 상속되지 않으므로 상속관계에서는 아무런 의미가 없다. 또한 상속되지 않으므로 abstract 또는 final 수식어를 가질 수 없다. 생성자는 객체의 생성시에만 호출되므로 static일 수 없다. 생성시에 락을 발생하는 것은 의미없으므로 synchronized 될 필요가 없다. native 생성자는 자바가상머신이 생성자를 통한 초기화에 부모 클래스의 초기화와 같은 보이지 않는 코드들을 조절할 수 없기 때문에 허용되지 않는다.

	또한 메소드가 아니므로 반환값은 void 조차 허용되지 않으며, 아예 반환값이란 있을 수 없다. 또한, 생성자의 이름은 메소드와는 달리 반드시 클래스 이름하고 같아야 한다.
	생성자의 파라미터 리스트는 일반 메소드의 파라미터와 동일한 방법이 적용된다. 없거나 한 개 이상의 파라미터를 가질 수 있으며, 각 파라미터는 타입과 이름을 가진다. 생성자의 시그너쳐는 파라미터 리스트에 의해 정해지며, 같은 시그너쳐(즉, 동일한 파라미터 순서)를 가진 생성자는 선언될 수 없으며, 컴파일 시에 에러가 발생한다.
	클래스는 마치 메소드의 오버로딩처럼 시그너쳐가 다른 여러 개의 생성자를 가질 수 있다. 실제로 메소드의 오버로딩과 동일한 개념으로 구현되며, 컴파일 시에 어떤 생성자가 실행될지 결정된다.
	또한, 생성자는 throws 리스트를 통해 발생될 예외 리스트를 가질 수 있다. 이것은 일반 메소드와 동일한 개념과 방법으로 사용된다. new 표현식으로 객체를 생성할 때 생성자가 호출되므로, 그때 throws 리스트의 예외가 발생할 수 있게 된다.
	
	**생성자는 자바 클래스의 멤버가 아니므로 상속과 같은 멤버가 가지는 특성을 가지고 있지 않다. 
	생성자는 클래스의 인스턴스인 객체를 생성할 때 초기화를 담당하는 코드 블록이며, 
	클래스의 상속관계에서 초기화를 수행할 수 있도록 부모 클래스의 생성자를 호출하는 특징이 있다.
	**https://javacan.tistory.com/entry/37

	
[애노테이션]
생성자 관련 애노테이션을 사용할 때 주의사항
	1. static 필드들은 스킵된다.
	2. 파라미터의 순서는 클래스에 있는 필드 순서에 맞춰서 생성하기 때문에 매우 주의해야 한다.
		→ 만약 클래스 필드의 순서를 바꾸었을 때 롬복이 자동적으로 생성자 파라미터 순서를 바꾸어 주기 때문에 주의하지 않으면 버그가 발생할 수 있다.
	3. AccessLevel을 꼭 설정해주어야 합니다. 	→ 세 애노테이션 모두 접근 제한자를 AccessLevel로 설정할 수 있습니다. 기본값은 public이지만 필요로 따라서 접근제한자를 설정해주어야 합니다.

@Getter/@Setter :  해당 필드에 대한 기본 getter/setter를 생성. 필드에 @Getter나 @Setter를 붙이지 않고 클래스에 붙인다면, static이 아닌 전체 필드에 @Getter와 @Setter 애노테이션이 적용됩니다.
@NoArgsConstructor : 이 애노테이션은 파라미터가 없는 생성자를 생성
	- 필드들이 final로 생성되어 있는 경우에는 필드를 초기화 할 수 없기 때문에 생성자를 만들 수 없고 에러가 발생. 이 때는 @NoArgsConstructor(force = true) 옵션을 이용해서 final 필드를 0, false, null 등으로 초기화를 강제로 시켜서 생성자를 만들 수 있습니다
	-  @NonNull 같이 필드에 제약조건이 설정되어 있는 경우, 생성자내 null-check 로직이 생성되지 않습니다. 후에 초기화를 진행하기 전까지 null-check 로직이 발생하지 않는 점을 염두하고 코드를 개발해야 합니다.
@RequiredArgsConstructor : 이 애노테이션은 추가 작업을 필요로 하는 필드에 대한 생성자를 생성하는 애노테이션입니다. 초기화 되지 않은 모든 final 필드, @NonNull로 마크돼있는 모든 필드들에 대한 생성자를 자동으로 생성해줍니다.
@AllArgsConstructor : 이 애노테이션은 클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성해줍니다. 만약 필드중에서 @NonNull 애노테이션이 마크되어 있다면 생성자 내에서 null-check 로직을 자동적으로 생성해줍니다.